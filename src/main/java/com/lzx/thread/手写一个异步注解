
1.利用aop,拦截只要我们的方法上有使用到@MayiktAsync就单独开启一个异步线程执行我们的目标方法


2.如何解决线程安全问题。
核心思想：上锁，分布式锁
在同一个jvm中，多个线程需要竞争锁的资源,最终只有一个线程能够获取到锁。谁可以获取到锁，谁就可以执行代码？
代码需要从那一块上锁？   ---可能需要发生线程安全的问题需要上锁

并发编程： 锁，重入锁，悲观锁，乐观锁，公平锁，非公平锁


synchronized;
    获取锁和释放锁都是由底层虚拟机实现好了

对一块代码加锁缺点：会影响程序执行效率。

在多线程的情况下，需要是同一个对象锁
synchronized(对象锁){
   需要保证线程安全的代码
}



synchronized锁基本用法：
1.修饰代码块,指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁
2.修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
3.修饰静态方法，作用于当前类对象（当前类.calss）加锁，进入同步代码前要获得当前类对象的锁



面试官问，线程实现如何同步？    ---------------线程如何保证线程安全性问题？
1.使用synchronized锁。从jdk1.6开始 锁的升级过程 偏向锁-->轻量级锁-->重量级锁
2.使用lock锁（JUC），需要自己实现锁的升级过程。底层是基于aqs+cas实现的
3.使用Threadlocal，需要注意内存泄漏的问题
4.原子类cas非阻塞式



sleep和wait的区别

sleep


注意：



